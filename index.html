<!DOCTYPE html>
<html lang="vi">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Badge 3D — Shield M</title>
<style>
  html,body{height:100%;margin:0;background:#f4f6f8}
  canvas{display:block}
  .ui{
    position:fixed;left:10px;top:10px;right:10px;
    font:600 14px system-ui,Segoe UI,Roboto;display:flex;gap:8px;align-items:center;justify-content:center;pointer-events:none
  }
  .pill{
    pointer-events:auto;background:#fff;padding:8px 12px;border-radius:999px;box-shadow:0 6px 20px rgba(0,0,0,.08);display:flex;gap:10px;align-items:center
  }
  .pill input{width:110px}
</style>
</head>
<body>
<div class="ui">
  <div class="pill">
    <span>Kích thước (mm):</span>
    <label>Rộng <input id="w" type="number" value="48" step="1"></label>
    <label>Dày <input id="t" type="number" value="3.2" step="0.1"></label>
    <label>Viền <input id="rim" type="number" value="0.8" step="0.1"></label>
    <label>Khe giữa <input id="gap" type="number" value="0.6" step="0.1"></label>
    <button id="apply">Áp dụng</button>
  </div>
</div>

<script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
    "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/"
  }
}
</script>

<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

let scene, camera, renderer, controls, group;
init();
buildBadge();

function init(){
  scene = new THREE.Scene();
  scene.background = new THREE.Color(0xf4f6f8);

  camera = new THREE.PerspectiveCamera(45, innerWidth/innerHeight, 0.1, 1000);
  camera.position.set(90, 90, 120);

  renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setPixelRatio(devicePixelRatio);
  renderer.setSize(innerWidth, innerHeight);
  document.body.appendChild(renderer.domElement);

  // lights
  scene.add(new THREE.AmbientLight(0xffffff, 0.6));
  const key = new THREE.DirectionalLight(0xffffff, 0.9);
  key.position.set(1, 2, 1.2);
  key.castShadow = true;
  scene.add(key);

  // ground
  const g = new THREE.Mesh(
    new THREE.PlaneGeometry(600,600),
    new THREE.MeshStandardMaterial({color:0xeeeeee, roughness:1})
  );
  g.rotation.x = -Math.PI/2; g.position.y = -20;
  scene.add(g);

  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableDamping = true;

  addEventListener('resize', onResize);
  renderer.setAnimationLoop(()=>{ controls.update(); renderer.render(scene,camera); });

  // UI
  document.getElementById('apply').onclick = ()=>{ buildBadge(); };
}

function onResize(){
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
}

// --------- PARAMETRIC BADGE ---------
function buildBadge(){
  const W  = parseFloat(document.getElementById('w').value);     // width mm
  const T  = parseFloat(document.getElementById('t').value);     // thickness
  const RIM= parseFloat(document.getElementById('rim').value);   // rim width
  const GAP= parseFloat(document.getElementById('gap').value);   // center gap

  if(group){ scene.remove(group); group.traverse(o=>o.geometry && o.geometry.dispose()); }
  group = new THREE.Group(); scene.add(group);

  // scale factor: 1 unit = 1 mm (giữ nguyên)
  const gold = new THREE.MeshPhysicalMaterial({color:0xd4af37, metalness:1, roughness:0.25, clearcoat:0.6, clearcoatRoughness:0.2});
  const black = new THREE.MeshStandardMaterial({color:0x161616, metalness:0.2, roughness:0.9});
  const red   = new THREE.MeshStandardMaterial({color:0x9c1b1b, metalness:0.1, roughness:0.6});
  const dark  = new THREE.MeshStandardMaterial({color:0x2b2b2b, metalness:0.1, roughness:0.7});

  // 1) Outer shield shape (2D path), symmetric like the photo
  const shapeOuter = shieldShape2D(W);

  // 2) BODY (solid)
  const body = new THREE.Mesh(new THREE.ExtrudeGeometry(shapeOuter, {depth:T, bevelEnabled:false}), black);
  body.rotation.x = -Math.PI/2;
  group.add(body);

  // 3) Rim (gold): outer minus inner (hole)
  const shapeRim = shieldShape2D(W);
  const hole = shieldShape2D(W - 2*RIM);
  shapeRim.holes.push(hole);
  const rim = new THREE.Mesh(new THREE.ExtrudeGeometry(shapeRim, {depth:T, bevelEnabled:false}), gold);
  rim.rotation.x = -Math.PI/2;
  group.add(rim);

  // 4) Enamel cavity (visual only): a slightly inset plate sitting lower than rim
  const enamelDepth = Math.min(0.8, T*0.35);
  const enamelZ = T - enamelDepth + 0.02; // just under rim
  const enamelShape = shieldShape2D(W - 2*RIM);
  const enamelGeo = new THREE.ExtrudeGeometry(enamelShape, {depth:enamelDepth, bevelEnabled:false});
  const enamel = new THREE.Mesh(enamelGeo, red);
  enamel.rotation.x = -Math.PI/2;
  enamel.position.y = 0;
  enamel.position.z = enamelZ;
  group.add(enamel);

  // 4b) Gradient-ish trick: add a darker overlay triangle to fake red->black fade
  const grad = new THREE.Mesh(
    new THREE.PlaneGeometry(W*0.9, (W*1.1)),
    dark
  );
  grad.rotation.x = -Math.PI/2;
  grad.position.z = enamelZ + enamelDepth*0.02;
  grad.position.y = 0;
  grad.renderOrder = 1;
  group.add(grad);
  // clip overlay inside enamel with stencil via depth (simple visual approximation)

  // 5) Center groove: a thin black “gap” plane on top to look split
  const groove = new THREE.Mesh(new THREE.BoxGeometry(GAP, W*1.4, enamelDepth+0.4), black);
  groove.rotation.x = -Math.PI/2;
  groove.position.z = enamelZ + enamelDepth/2;
  group.add(groove);

  // 6) Raised "M" logo (parametric blocks). Replace with imported GLB/SVG extrude when có vector thật.
  const M = buildM3D(W);
  M.traverse(o=>{ if(o.isMesh) o.material = gold; });
  M.rotation.x = -Math.PI/2;
  M.position.z = enamelZ + enamelDepth + 0.01; // rise above enamel
  group.add(M);

  // center & scale view
  const box = new THREE.Box3().setFromObject(group);
  const size = box.getSize(new THREE.Vector3()).length();
  const center = box.getCenter(new THREE.Vector3());
  controls.target.copy(center);
  camera.position.set(center.x + size*0.8, center.y + size*0.7, center.z + size*0.9);
  camera.lookAt(center);
}

function shieldShape2D(W=48){
  // Points based on a stylized shield (mm). Edit to match ảnh sát hơn.
  const pts = [
    [ 0,  24],
    [ 9,  22],
    [11.5,15],
    [12.5, 6],
    [ 9.5,-4],
    [ 6.5,-10],
    [ 0, -18],
    [-6.5,-10],
    [-9.5,-4],
    [-12.5,6],
    [-11.5,15],
    [-9,22],
    [ 0,24]
  ];
  // scale to desired width (design width ≈ 48)
  const s = W/48;
  const shape = new THREE.Shape();
  shape.moveTo(pts[0][0]*s, pts[0][1]*s);
  for(let i=1;i<pts.length;i++) shape.lineTo(pts[i][0]*s, pts[i][1]*s);
  return shape;
}

function buildM3D(W){
  // A blocky "M" built from simple extrusions; replace with real SVG/GLB when available
  const h = W*0.40, w = W*0.38, t = Math.max(0.9, W*0.02); // thickness (height)
  const mat = new THREE.MeshPhysicalMaterial({color:0xd4af37, metalness:1, roughness:0.28, clearcoat:0.5});
  const g = new THREE.Group();

  const add = (geo, x=0, y=0, rot=0)=>{
    const m = new THREE.Mesh(geo, mat);
    m.rotation.z = rot;
    m.position.set(x,y,0);
    g.add(m);
  };

  // stem center
  add(new THREE.BoxGeometry(w*0.18, h, t));
  // two outer legs
  add(new THREE.BoxGeometry(w*0.22, h*0.95, t), -w*0.28, 0, 0.28);
  add(new THREE.BoxGeometry(w*0.22, h*0.95, t),  w*0.28, 0,-0.28);
  // two inner “fangs”
  add(new THREE.BoxGeometry(w*0.18, h*0.50, t), -w*0.18,  h*0.15, -0.25);
  add(new THREE.BoxGeometry(w*0.18, h*0.50, t),  w*0.18,  h*0.15,  0.25);

  return g;
}
</script>
</body>
</html>
